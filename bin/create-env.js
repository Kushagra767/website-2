// @ts-check
const { resolve } = require('path');
const { writeFile } = require('fs');
const { argv } = require('yargs');

// This is good for local dev environments, when it's better to
// store a projects environment variables in a .gitignore'd file
require('dotenv').config();

// Would be passed to script like this:
// `ts-node set-env.ts --environment=dev`
// we get it from yargs's argv object
const environment = argv.environment;
const isProd = environment === 'prod';

const targetPath = resolve(__dirname, `../src/environments/environment${environment ? `.${environment}` : ''}.ts`);
const envConfigFile = `/**
 * DO NOT MODIFY THIS FILE DIRECTLY
 * Autogenerated file by the bin/create-env.js script
 * @generated ${new Date().toISOString()}
 */
export const environment = {
	production: ${isProd},
	buildNumber: 'v0#' + Date.now(),
	assetCDNHost: '${process.env.ASSET_CDN_HOST}',
	cockpitAPIURL: '${process.env.COCKPIT_API_URL}',
	cockpitAPIKey: '${process.env.COCKPIT_API_KEY}',
	graphQLHostURL: '${process.env.GRAPHQL_HOST_URL}',
	gtmId: '${process.env.GTM_ID}',
	gcpKey: '${process.env.GCP_KEY}',
	gcpStaticMapsSecret: '${process.env.GCP_STATIC_MAPS_SECRET}'
};

import 'zone.js/dist/zone-error';
`
writeFile(targetPath, envConfigFile, function (err) {
	if (err) {
		console.log(err);
	}

	console.log(`ðŸ›  Environment generated at ${targetPath}`);
});
